---
description: API 메서드 작성 룰 (Axios/타입/JSDoc/에러 공통)
globs: app/**/{services}/**/*.ts
alwaysApply: false
---

## 목표

- 일관된 API 함수 시그니처, 네이밍, 타입, JSDoc 주석 작성 룰 정립
- Axios 인스턴스(`apiClient`) 특성에 맞춘 반환 타입/에러 처리 표준화
- React/상태 의존성 제거(서비스 계층은 순수 함수만)

## 폴더 구조 규정 (services 디렉토리)

- 사용: `app/{domain}/services/` 아래에 다음 파일을 둡니다
  - `apis.ts` ← API 메서드 (Axios 순수 함수)
  - `query-keys.ts` ← React Query에서 사용되는 쿼리 키 팩토리
  - `queries.ts` ← React Query 조회 훅
  - `mutations.ts` ← React Query 뮤테이션 훅
- 동적 라우팅(`app/{domain}/[id]/…`) 폴더는 UI/페이지 전용. 서비스 코드는 항상 도메인 루트 `services/`에 위치
- 기존 `app/{domain}/apis/*`는 점진적으로 `services/`로 이전

## Axios 사용 규칙

- `apiClient`는 응답 인터셉터에서 `response.data`를 바로 반환함. 즉 `apiClient.get<T>(...)`의 결과는 `T` 타입 데이터 그 자체임
  - 금지: `const res = await apiClient.get<T>(...); return res.data;`
  - 허용: `return apiClient.get<T>(...)`
- HTTP 메서드와 파라미터 위치
  - GET: `apiClient.get<T>(url, { params })`
  - POST/PUT/PATCH: `apiClient.post<T>(url, body, { params })`
  - 금지: 본문(body) 객체 안에 `params` 키로 쿼리 전달
- 직렬화: `qs`가 설정되어 있으므로 객체/배열 쿼리 파라미터 사용 가능
- API 함수는 항상 순수 함수. React 훅/상태/라우터 등 UI 의존 금지
  - 금지: 인터셉터/서비스 내 `useRouter`, `useState`, `window` 직접 접근

## 네이밍 규칙 (동사 + 리소스 + 선택적 수식어)

- 조회: `get<Resource>`, 상세: `get<Resource>Detail`, 목록(페이징): `get<Resource>List`
- 생성: `post<Resource>`, 수정: `put<Resource>` 또는 `patch<Resource>`
- 삭제: `delete<Resource>`
- 불리언 토글: `patch<Resource><Action>` 예) `patchBillBookmark`

## 타입 선언 규칙

- 반환 타입은 도메인 `types/`에 정의된 인터페이스/타입을 사용
- 서비스 입력은 직렬화 가능하고 UI 무관한 원시/객체 타입만 허용
  - 금지: `Dispatch<SetStateAction<...>>` 같은 React 타입을 API 파라미터에 포함
  - 권장: 런타임 검증은 도메인 `validation/*.schema.ts`의 Zod 스키마를 단일 소스로 사용하고 `z.infer`로 타입 생성

## JSDoc 템플릿 (필수)

```ts
/**
 * @description 법안 상세 조회 API
 * @param billId - 법안 ID
 * @returns BillResponse
 */
export const getBillDetail = (billId: string) => apiClient.get<BillResponse>(`/bill/detail/${billId}`);
```

고급 예시 (POST/PATCH, params/에러 주석):

```ts
/**
 * @description 법안 북마크 토글
 * @param billId - 법안 ID
 * @param likeChecked - 북마크 상태(true: 추가, false: 해제)
 * @returns BookmarkResponse
 * @example
 * const data = await patchBillBookmark('BILL-123', true);
 */
export const patchBillBookmark = (billId: string, likeChecked: boolean) =>
  apiClient.patch<BookmarkResponse>('/bill/user/bookmark', { bill_id: billId, likeChecked });
```

## 에러 처리

- 기본: 서비스 함수에서는 `try/catch`로 삼키지 말고 예외 전파. 필요 시 메시지 변환만 수행
- 에러 타입: `unknown` -> `AxiosError` 내 서버 스키마로 안전하게 내립니다

```ts
import type { AxiosError } from 'axios';

export const getSomething = async () => {
  try {
    return await apiClient.get<Something>('/something');
  } catch (err) {
    const error = err as AxiosError<{ message?: string }>; // 서버 표준 메시지
    throw new Error(error.response?.data?.message ?? 'Request failed');
  }
};
```

## 요청 파라미터 가이드

- RESTful 경로 파라미터는 템플릿 문자열로, 검색·필터·페이지네이션은 `params`로

```ts
export const getBills = (page = 0, size = 20, stage?: string) =>
  apiClient.get<FeedResponse>('/bill/mainfeed', { params: { page, size, stage } });
```

## 응답 표준

- 모든 API 함수는 실제 데이터(`T`)만 반환. AxiosResponse 반환 금지
- Pagination이 있으면 `types/`에서 통일된 `Pagination` 타입을 참조

## 모듈 경계

- `apis.ts`는 네트워크 계층만. 캐시 무효화/옵티미스틱 업데이트 등은 `queries.ts`/`mutations.ts`에서 담당

## 고급 패턴 (권장)

- 런타임 응답 검증(Zod)

```ts
import { z } from 'zod';

const BillSchema = z.object({ id: z.string(), title: z.string() });
type Bill = z.infer<typeof BillSchema>;

export const getBill = async (id: string): Promise<Bill> => {
  const data = await apiClient.get<unknown>(`/bill/detail/${id}`);
  return BillSchema.parse(data);
};
```

- 요청 취소/타임아웃

```ts
export const withTimeout = <T>(p: Promise<T>, ms = 15000) =>
  new Promise<T>((resolve, reject) => {
    const id = setTimeout(() => reject(new Error('Request timeout')), ms);
    p.then(
      (v) => {
        clearTimeout(id);
        resolve(v);
      },
      (e) => {
        clearTimeout(id);
        reject(e);
      },
    );
  });

export const getFeed = (page: number, signal?: AbortSignal) =>
  withTimeout(apiClient.get<FeedResponse>('/bill/mainfeed', { params: { page, size: 3 }, signal }));
```

- 파일 업로드

```ts
export const uploadAttachment = (file: File) => {
  const form = new FormData();
  form.append('file', file);
  return apiClient.post<UploadResponse>('/attachments', form, {
    headers: { 'Content-Type': 'multipart/form-data' },
  });
};
```

- 멱등성 키(Idempotency-Key) (서버 지원 시)

```ts
export const createPayment = (dto: CreatePaymentDto, idemKey: string) =>
  apiClient.post<PaymentResponse>('/payments', dto, { headers: { 'Idempotency-Key': idemKey } });
```

- 인증 토큰 주입/갱신

> 인터셉터는 React 훅/라우터에 의존하지 않아야 합니다. 토큰 갱신은 별도 순수 함수로 구성하고, 실패 시 콜백을 주입합니다.

```ts
// app/common/lib/auth.ts
export async function reissueAccessToken(): Promise<void> {
  /* ... */
}
```

- API 합성기(컴포지션)

## Zod와 함께 쓰는 인코더/디코더 패턴

```ts
// validation
export const CreateBillInputSchema = z.object({ title: z.string().min(1) }).strict();
export const CreateBillServerSchema = CreateBillInputSchema.transform((v) => ({ title: v.title }));
export const CreateBillResponseSchema = z.object({ id: z.string() }).strict();

// apis.ts
export const postBill = async (input: z.input<typeof CreateBillInputSchema>) => {
  const body = CreateBillServerSchema.parse(input);
  const data = await apiClient.post<unknown>('/bill', body);
  return CreateBillResponseSchema.parse(data);
};
```

```ts
export async function getBillWithExtras(billId: string) {
  const [detail, popular] = await Promise.all([getBillDetail(billId), getBillPopular()]);
  return { detail, popular } as const;
}
```
