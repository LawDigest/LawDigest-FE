---
description: Zod 활용 룰 (런타임 검증/정규화/경계 안전)
globs: app/**/*
alwaysApply: false
---

## 원칙 (Validate At The Boundaries)

- 외부 경계에서 들어오고/나가는 모든 데이터는 Zod로 검증하고 필요 시 정규화합니다
- 스키마가 단일 소스 오브 트루스(SSOT)가 되도록 타입은 `z.infer`로만 생성합니다
- 입력과 출력이 다른 경우 `z.input<typeof Schema>`/`z.output<typeof Schema>`를 구분합니다

## 파일 구조 권장

- 도메인별: `app/{domain}/validation/*.schema.ts`
- 공용: `app/common/validation/*.schema.ts`
- 네이밍: `ThingSchema`, 타입은 `Thing`, `ThingInput`, `ThingOutput`

```ts
// app/bill/validation/bill.schema.ts
import { z } from 'zod';

export const PaginationSchema = z.object({ page_number: z.number(), last_page: z.boolean() }).strict();
export const BillSchema = z
  .object({ id: z.string(), title: z.string().trim().min(1), bookmarked: z.boolean().optional() })
  .strict();
export const FeedSchema = z.object({ bill_list: z.array(BillSchema), pagination_response: PaginationSchema }).strict();

export type Bill = z.infer<typeof BillSchema>;
export type Feed = z.infer<typeof FeedSchema>;
```

## 네트워크 경계 (API)

- 응답은 `apis.ts`에서 `Schema.parse`로 검증 후 반환합니다
- 요청 DTO는 입력 스키마로 검증하고 `.transform`으로 서버 기대 형태로 매핑합니다

```ts
// apis.ts
import { FeedSchema, type Feed } from '../validation/bill.schema';

export const getMainfeed = (page: number, stage?: string): Promise<Feed> =>
  apiClient.get<unknown>('/bill/mainfeed', { params: { page, size: 3, stage } }).then(FeedSchema.parse);

// 요청 DTO 예: 클라이언트 입력 → 서버 스키마 변환
const CreateBookmarkInput = z.object({ billId: z.string(), checked: z.boolean() });
const CreateBookmarkServer = CreateBookmarkInput.transform((v) => ({ bill_id: v.billId, likeChecked: v.checked }));
export const patchBillBookmark = (input: z.input<typeof CreateBookmarkInput>) =>
  apiClient.patch<BookmarkResponse>('/bill/user/bookmark', CreateBookmarkServer.parse(input));
```

## URL/Route/Search Params

```ts
import { z } from 'zod';
const ListParamsSchema = z.object({
  stage: z.enum(['ALL', 'IN_PROGRESS', 'DONE']).optional().default('ALL'),
  page: z.coerce.number().int().min(0).default(0),
});
export type ListParams = z.output<typeof ListParamsSchema>;
export const parseListParams = (sp: URLSearchParams): ListParams =>
  ListParamsSchema.parse(Object.fromEntries(sp.entries()));
```

## Storage/Zustand Persist

```ts
const PrefsSchema = z
  .object({
    theme: z.enum(['light', 'dark']).default('light'),
    itemsPerPage: z.number().int().min(3).max(50).default(10),
  })
  .strict();
type Prefs = z.infer<typeof PrefsSchema>;

export const prefsStorage = {
  get(): Prefs | undefined {
    const raw = localStorage.getItem('prefs');
    if (!raw) return undefined;
    const parsed = PrefsSchema.safeParse(JSON.parse(raw));
    return parsed.success ? parsed.data : undefined;
  },
  set(v: z.input<typeof PrefsSchema>) {
    localStorage.setItem('prefs', JSON.stringify(PrefsSchema.parse(v)));
  },
};

// Zustand migrate에서 사용
// migrate: (persisted) => PrefsSchema.parse(persisted ?? {})
```

## 환경 변수/설정

```ts
const EnvSchema = z
  .object({ NEXT_PUBLIC_URL: z.string().url(), NODE_ENV: z.enum(['development', 'test', 'production']) })
  .strict();
export const env = EnvSchema.parse({ NEXT_PUBLIC_URL: process.env.NEXT_PUBLIC_URL, NODE_ENV: process.env.NODE_ENV });
```

## SEO 메타데이터/Analytics 페이로드

```ts
export const SEOInputSchema = z
  .object({
    title: z.string().min(1),
    description: z.string().min(1).max(160),
    images: z.array(z.string().url()).optional(),
  })
  .strict();
export const BookmarkEventSchema = z.object({ billId: z.string(), action: z.enum(['like', 'unlike']) }).strict();
```

## 정규화/변환/교차검증

```ts
export const BillNormalizedSchema = z
  .object({ id: z.string(), title: z.string().transform((s) => s.trim()), publishedAt: z.coerce.date() })
  .superRefine((v, ctx) => {
    if (v.title.length < 2) ctx.addIssue({ code: z.ZodIssueCode.custom, message: '제목이 너무 짧습니다.' });
  })
  .strict();
```

## 헬퍼 유틸

```ts
export function createSchemaTools<T extends z.ZodTypeAny>(schema: T) {
  return {
    parse: (data: unknown) => schema.parse(data),
    safe: (data: unknown) => schema.safeParse(data),
    defaulted: <D>(data: unknown, fallback: D) =>
      schema.safeParse(data).success ? (schema.parse(data) as any) : fallback,
  } as const;
}
```

## 테스트 전략

- MSW 핸들러/픽스처는 Zod 스키마로 검증합니다
- 에러 케이스는 `safeParse` 실패 경로를 반드시 커버합니다
- 필요 시 `zod-mock`/`@anatine/zod-mock`으로 페이로드 생성

## 성능 팁

- 무거운 스키마는 부분 스키마로 나누어 컴포지션
- 무한스크롤에서는 페이지별 파싱 후 평탄화(`pages.flatMap`)로 사용
- 실패 허용 경계에서는 `safeParse`로 폴백 처리

## 도입 체크리스트

- [ ] 각 도메인에 `validation/*.schema.ts` 생성, 스키마/타입 export
- [ ] API 응답/요청은 반드시 Zod로 검증 후 반환
- [ ] URL/Search params 파서 도입, 잘못된 값은 기본값으로 대체
- [ ] Persist/Env/Analytics/SEO 입력 모두 스키마 도입
