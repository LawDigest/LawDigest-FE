---
description: React Query 훅 작성 룰 (키/옵션/SSR/무한스크롤/뮤테이션)
globs: app/**/{services}/queries.ts
alwaysApply: false
---

## 목표

- 일관된 쿼리 키, 훅 네이밍, 옵션 기본값, 주석 및 제네릭 시그니처 정립
- SSR(서버 프리패치), Suspense, 무한스크롤, 옵티미스틱 업데이트를 위한 베스트 프랙티스 제공

## 폴더/파일 역할

- `apis.ts`: API 순수 함수 집합 (네트워크만)
- `query-keys.ts`: 쿼리 키 팩토리(권장)
- `queries.ts`: 조회 훅(useQuery/useInfiniteQuery/useSuspenseInfiniteQuery)
- `mutations.ts`(선택): 생성/수정/삭제 훅(useMutation) 및 캐시 무효화 전략

## 쿼리 키 규칙 (배열, 도메인 우선)

- 최소: `['domain', 'resource', param?]`
- 상세: `['congressman', 'detail', congressmanId]`
- 목록: `['bill', 'mainfeed', { stage, pageSize }]`
- 키는 상수 함수로 생성 권장

```ts
// app/{route}/services/query-keys.ts
export const billKeys = {
  root: () => ['bill'] as const,
  mainfeed: (stage?: string) => [...billKeys.root(), 'mainfeed', stage ?? 'all'] as const,
  detail: (billId: string) => [...billKeys.root(), 'detail', billId] as const,
};
```

## 훅 네이밍/시그니처 규칙

- `useGet<Resource>`: 조회, `useInfinite<Resource>`: 무한스크롤, `useMutate<Resource><Action>`: 변경
- 입력은 UI 친화적이며 제네릭 옵션을 통해 확장 가능
- 반환 타입은 React Query 훅 반환 그대로 노출(일관성)

### useQuery 기본 템플릿

```ts
import { useQuery, type UseQueryOptions } from '@tanstack/react-query';
import { billKeys } from './query-keys';
import { getBillDetail } from './apis';

/**
 * @description 법안 상세 쿼리 훅
 */
export const useGetBillDetail = <TData = BillResponse, TError = unknown>(
  billId: string,
  options?: Omit<
    UseQueryOptions<BillResponse, TError, TData, ReturnType<typeof billKeys.detail>>,
    'queryKey' | 'queryFn'
  >,
) =>
  useQuery({
    queryKey: billKeys.detail(billId),
    // queryFn은 반드시 Zod로 검증된 데이터만 반환해야 함
    queryFn: () => getBillDetail(billId),
    ...options,
  });
```

### useInfiniteQuery 기본 템플릿

```ts
import { useInfiniteQuery } from '@tanstack/react-query';
import { billKeys } from './query-keys';
import { getBills } from './apis';

/**
 * @description 법안 메인피드 무한스크롤 훅
 */
export const useInfiniteBills = (stage?: string) =>
  useInfiniteQuery({
    queryKey: billKeys.mainfeed(stage),
    queryFn: ({ pageParam = 0 }) => getBills(pageParam, 3, stage),
    initialPageParam: 0,
    getNextPageParam: (data) => {
      const { last_page, page_number } = data.pagination_response ?? ({} as any);
      return last_page ? undefined : (page_number ?? 0) + 1;
    },
  });
```

### useMutation 기본 템플릿 (옵티미스틱/무효화)

```ts
import { useMutation, useQueryClient, type UseMutationOptions } from '@tanstack/react-query';
import { billKeys } from './query-keys';
import { patchBillBookmark } from './apis';

/**
 * @description 법안 북마크 토글 뮤테이션 훅
 */
export const useMutateBillBookmark = <TError = unknown, TContext = unknown>(
  billId: string,
  options?: Omit<UseMutationOptions<BookmarkResponse, TError, boolean, TContext>, 'mutationFn'>,
) => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (likeChecked: boolean) => patchBillBookmark(billId, likeChecked),
    onSuccess: (data, variables, context) => {
      queryClient.invalidateQueries({ queryKey: billKeys.detail(billId) });
      queryClient.invalidateQueries({ queryKey: billKeys.mainfeed() });
      options?.onSuccess?.(data, variables, context);
    },
    ...options,
  });
};
```

## 옵션 기본값 가이드

- 전역 기본값은 `app/providers.tsx`의 `QueryClient`에서 설정(staleTime 등)
- 훅 레벨에서는 다음을 권장
  - `gcTime`: 도메인 요구에 맞게 명시적 설정 고려
  - `enabled`: 입력 파라미터 유효성 검사로 조건부 실행
  - `staleTime`: 서버 빈도에 맞춰 상수로 조정
  - `retry`: 0 또는 1–3회. 인증/권한 에러는 재시도 금지
  - `placeholderData`: skeleton 최소화. 페이지 전환에는 `keepPreviousData: true`
  - `select`: 컴포넌트가 필요한 모양으로 데이터 슬라이싱. 반환 타입은 Zod 기반 타입으로 협업

## Suspense/SSR 패턴

- 클라이언트 컴포넌트: `useSuspenseQuery`/`useSuspenseInfiniteQuery` 사용 가능
- 서버 프리패치(Next.js 14+): 서버에서 `QueryClient`로 `prefetchQuery` 또는 `fetchQuery` 후 `dehydrate` 전달
- 현재 코드에서 `queryClient.fetchQuery`를 훅으로 노출한 패턴은 SSR 프리패치를 위한 의도라면 `queries.ts` 대신 서버 레이어에서 호출 권장

SSR 서버 예시:

```ts
// server-side (route/page loader)
const queryClient = new QueryClient();
await queryClient.prefetchQuery({ queryKey: billKeys.detail(billId), queryFn: () => getBillDetail(billId) });
const dehydrated = dehydrate(queryClient);
```

클라이언트 복원:

```tsx
<HydrationBoundary state={dehydrated}> ... </HydrationBoundary>
```

## 타입/제네릭 규칙

- 훅은 가능한 제네릭으로 `TData`, `TError` 노출하여 `select` 변환 지원
- 뮤테이션 훅은 `UseMutationOptions<TReturn, TError, TVariables, TContext>`를 Omit하여 옵션 전달

## 키/무효화 일관성

- invalidate/notify 시에는 반드시 같은 키 팩토리 사용
- 문자열 경로(`/bill/detail`)를 그대로 키로 쓰는 패턴은 지양하고 키 팩토리로 마이그레이션 권장

## 주석 규칙

- 훅 블록 바로 위에 TSDoc 작성: 목적, 주요 파라미터 설명, 반환 의미
- 동작 예시는 간단히(한두 줄)

## 점진적 리팩토링 체크리스트

- [ ] 쿼리 키 팩토리 도입(`query-keys.ts`)
- [ ] `queryClient.fetchQuery`를 서버 프리패치로 이동
- [ ] 무한스크롤 `getNextPageParam` 공통화 유틸 도입 고려
- [ ] `queries.ts` 제네릭 옵션 도입(`UseQueryOptions`/`UseMutationOptions`)

## 고급 패턴

- `select`로 데이터 모양 최적화 (컴포넌트 최소 데이터 의존)

```ts
useGetBillDetail(billId, { select: (d) => ({ id: d.id, title: d.title }) });
```

- 의존 쿼리

```ts
const user = useGetUserInfo(undefined, { select: (u) => u.id });
const bills = useInfiniteBills(undefined, { enabled: !!user.data });
```

- 병렬 쿼리

```ts
const results = useQueries({
  queries: [1, 2, 3].map((id) => ({ queryKey: billKeys.detail(String(id)), queryFn: () => getBillDetail(String(id)) })),
});
```

- 옵티미스틱 업데이트

```ts
const qc = useQueryClient();
const m = useMutation({
  mutationFn: (checked: boolean) => patchBillBookmark(billId, checked),
  onMutate: async (checked) => {
    await qc.cancelQueries({ queryKey: billKeys.detail(billId) });
    const prev = qc.getQueryData<BillResponse>(billKeys.detail(billId));
    qc.setQueryData<BillResponse>(billKeys.detail(billId), (d) => (d ? { ...d, bookmarked: checked } : d));
    return { prev };
  },
  onError: (_e, _v, ctx) => {
    if (ctx?.prev) qc.setQueryData(billKeys.detail(billId), ctx.prev);
  },
  onSettled: () => qc.invalidateQueries({ queryKey: billKeys.detail(billId) }),
});
```

- 무한스크롤 페이지 평탄화 셀렉터

```ts
const pages = data?.pages.flatMap((p) => p.bill_list) ?? [];
```

- 네트워크 모드

## Zod와의 결합 권장

- queryFn에서 Zod `Schema.parse`로 검증된 데이터만 반환합니다
- `select`에서는 필요한 모양을 최소화하되, 가능한 Zod 타입이 유지되도록 domain 스키마를 기준으로 슬라이스합니다
- `placeholderData`/`initialData`를 제공할 때도 도메인 스키마와 동일한 모양을 준수합니다

```ts
useQuery({ queryKey, queryFn, networkMode: 'always' }); // 백그라운드 중요 작업
```
